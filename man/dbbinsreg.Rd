% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dbbinsreg.R
\name{dbbinsreg}
\alias{dbbinsreg}
\title{Database-native binned regression (binsreg-compatible API)}
\usage{
dbbinsreg(
  fml,
  data = NULL,
  path = NULL,
  dots = c(0, 0),
  line = NULL,
  linegrid = 20,
  nbins = 20,
  binspos = "qs",
  sample_frac = NULL,
  ci = TRUE,
  cb = FALSE,
  vcov = NULL,
  level = 0.95,
  nsims = 500,
  strategy = "auto",
  conn = NULL,
  verbose = getOption("dbreg.verbose", FALSE)
)
}
\arguments{
\item{fml}{A \code{\link[stats]{formula}} representing the binscatter relation.
The first variable on the RHS is the running variable; additional variables
are controls. Fixed effects go after \code{|}. Examples:
\itemize{
\item \code{y ~ x}: simple binscatter
\item \code{y ~ x + w1 + w2}: binscatter with controls
\item \code{y ~ x | fe}: binscatter with fixed effects
\item \code{y ~ x + w1 + w2 | fe}: binscatter with controls and fixed effects
}}

\item{data}{A data source: R dataframe, database table name (character), or
a lazy table object (e.g., from \code{dplyr::tbl()}) pointing to a database table.}

\item{path}{Character string giving a path to data file(s) on disk. This is
an alias for \code{data} for consistency with \code{\link{dbreg}}. Can include
file globbing for Hive-partitioned datasets, e.g.
\code{"read_parquet('mydata/**/*.parquet')"}.}

\item{dots}{A vector \code{c(p, s)} specifying the polynomial degree \eqn{p} and
smoothness \eqn{s} for the dots (point estimates at bin means). Default is
\code{c(0, 0)} for canonical binscatter (bin means). Set to \code{NULL} or \code{FALSE} to
suppress dots. The smoothness \code{s} must satisfy \code{s <= p}.}

\item{line}{A vector \code{c(p, s)} specifying the polynomial degree \eqn{p} and
smoothness \eqn{s} for the line (evaluated on a grid within bins). Default
is \code{NULL} (no line). Set to \code{TRUE} for \code{c(0, 0)} or a vector like \code{c(1, 1)}
for piecewise linear with continuity constraints. The smoothness \eqn{s}
must satisfy \code{s <= p}.}

\item{linegrid}{Number of evaluation points per bin for the line. Default is 20.}

\item{nbins}{Integer number of bins. Default is 20.}

\item{binspos}{Bin positioning method. One of either \code{"qs"} (quantile-spaced,
equal-count bins, the default), \code{"es"} (evenly-spaced, equal-width bins),
or a numeric vector of knot positions for manual specification.}

\item{sample_frac}{Numeric in the range \verb{(0,1]}. Controls the random sampling
fraction for bin boundary computation on large datasets. If \code{NULL} (the
default), then sampling is automatic: \code{0.1} (10\%) for datasets exceeding 1
million rows and \code{1} (100\%) otherwise. Note that sampling is only used for
computing the bin boundaries, since this requires an expensive ranking
operation. The subsequent, primary regression operations use all of the
data.}

\item{ci}{Logical. Calculate standard errors and confidence intervals for dots?
Default is \code{TRUE}.}

\item{cb}{Logical. Calculate simultaneous confidence bands using simulation?
Default is \code{FALSE}.}

\item{vcov}{Character string or formula for standard errors. Options are
\code{"HC1"} (default, heteroskedasticity-robust, matches
\code{\link[binsreg]{binsreg}}), \code{"iid"}, or a one-sided formula for
clustered standard errors (e.g., \code{~cluster_var}).}

\item{level}{Numeric in the range \verb{[0,1]}, giving the confidence level for
the confidence levels and/or bands. Default is \code{0.95}.}

\item{nsims}{Number of simulation draws for confidence band computation.
Default is 500. Only used when \code{cb = TRUE}.}

\item{strategy}{Acceleration strategy passed to \code{\link{dbreg}} when
smoothness is zero. Options are \code{"auto"} (default), \code{"compress"}, or
\code{"scan"}. This parameter is ignored when \code{s} (smoothness parameter in
\code{dots} or \code{lines}) > 0. See \code{\link{dbreg}} for details.}

\item{conn}{Database connection. If \code{NULL} (default), an ephemeral DuckDB
connection will be created.}

\item{verbose}{Logical. Print auto strategy and progress messages to the
console? Defaults to \code{FALSE}. This can be overridden for a single call
by supplying \code{verbose = TRUE}, or set globally via
\code{options(dbreg.verbose = TRUE)}.}
}
\value{
A list of class "dbbinsreg" containing:
\describe{
\item{data.dots}{Data frame with dot estimates (one row per bin): \code{x} (bin mean),
\code{bin}, \code{fit} (fitted value), and if \code{ci=TRUE}: \code{se}, \code{lwr}, \code{upr}.}
\item{data.line}{Data frame with line estimates (multiple rows per bin): \code{x},
\code{bin}, \code{fit}. Only present if \code{line} is specified.}
\item{data.bin}{Data frame with bin geometry: \code{bin.id}, \code{left.endpoint},
\code{right.endpoint}.}
\item{model}{The fitted \code{dbreg} model object (for dots).}
\item{opt}{List of options used: \code{dots}, \code{line}, \code{nbins}, \code{binspos}, etc.}
}
}
\description{
Performs binned regression entirely in SQL, returning plot-ready data with
estimated bin means or piecewise polynomial fits. The API is designed to be compatible
with the \pkg{binsreg} package by Cattaneo, Crump, Farrell, and Feng (2024).
Supports unconditional and conditional models (with controls and/or fixed effects).
}
\details{
\subsection{Relationship to binsreg}{

This function aims to provide an API similar to the \pkg{binsreg} package.
Key parameter mappings:
\itemize{
\item \code{dots = c(0,0)}: Canonical binscatter (bin means), equivalent to binsreg default
\item \code{dots = c(p,0)}: Piecewise polynomial of degree \eqn{p}, no smoothness constraints
\item \code{dots = c(p,s)}: Piecewise polynomial with \eqn{s} smoothness constraints at knots
\item \code{line = c(p,s)}: Same polynomial evaluated on a grid for smooth visualization
\item \code{binspos = "qs"}: Quantile-spaced bins (\code{\link[binsreg]{binsreg}} default)
\item \code{binspos = "es"}: Evenly-spaced bins
}

Unlike \code{\link[binsreg]{binsreg}}, \code{dbbinsreg} executes entirely in
SQL, making it suitable for large databases that cannot fit in memory.
}

\subsection{Confidence intervals vs confidence bands}{

When \code{ci = TRUE} (default), pointwise confidence intervals (CIs) are computed
at each bin mean using standard asymptotic theory. When \code{cb = TRUE},
simultaneous confidence bands (CBs) are computed using a simulation-based
sup-\eqn{t} procedure:
\enumerate{
\item Draw \code{nsims} samples from the asymptotic distribution of the estimator
\item Compute the supremum of the \eqn{t}-statistics across all bins for each draw
\item Use the (\eqn{1-\alpha}) quantile of these suprema as the critical value
}

The confidence band is wider than pointwise CIs and provides simultaneous
coverage: with (\eqn{1-\alpha}) probability, the entire true function lies
within the band. This is useful for making statements about the overall shape
of the relationship rather than individual point estimates.

Note: Unlike \code{\link[binsreg]{binsreg}}, which evaluates CB on a fine
grid within each bin, \code{dbbinsreg} computes CB only at bin means (same points
as CI). This is much simpler for our backend SQL implementation and should be
sufficient for most applications.
}

\subsection{Note on quantile bin boundaries}{

When using quantile-spaced bins (\code{binspos = "qs"}), \code{dbbinsreg} uses SQL's
\code{NTILE()} window function, while \code{\link[binsreg]{binsreg}} uses R's
\code{\link[stats]{quantile}} with \code{type = 2}. These algorithms have slightly
different tie-breaking behavior, which can cause small differences in bin
assignments at boundaries. In practice, differences are typically <1\% and
become negligible with larger datasets. To match
\code{\link[binsreg]{binsreg}} exactly, compute quantile breaks on a subset
of data in R and pass them via the \code{binspos} argument as a numeric vector.
}
}
\examples{
\dontrun{
cw = as.data.frame(ChickWeight)

# Canonical binscatter: bin means (default)
dbbinsreg(weight ~ Time, cw, nbins = 10)

# Piecewise linear, no smoothness
dbbinsreg(weight ~ Time, cw, nbins = 10, dots = c(1, 0))

# Piecewise quadratic with C1 continuity
dbbinsreg(weight ~ Time, cw, nbins = 10, dots = c(2, 1))

# With line overlay for smooth visualization
dbbinsreg(weight ~ Time, cw, nbins = 10, dots = c(0, 0), line = c(1, 1))

# With fixed effects (diet type)
dbbinsreg(weight ~ Time | Diet, cw, nbins = 10, dots = c(1, 0))
}
}
\references{
Cattaneo, M. D., R. K. Crump, M. H. Farrell, and Y. Feng (2024).
On Binscatter. \emph{American Economic Review}, 114(5): 1488-1514.
}

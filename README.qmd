---
format: gfm
---

<!-- README.md is generated from README.qmd. Please edit that file -->

```{r}
#| label: setup
#| include: false
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-"
)
```

# dbreg

<!-- badges: start -->

<a href="https://CRAN.R-project.org/package=dbreg"><img src="https://www.r-pkg.org/badges/version/dbreg" class="img-fluid" alt="CRAN version"></a>
<a href="https://grantmcdermott.r-universe.dev"><img src="https://grantmcdermott.r-universe.dev/badges/dbreg" class="img-fluid" alt="R-universe version"></a>
<a href="https://github.com/grantmcdermott/dbreg/actions/workflows/R-CMD-check.yaml"><img src="https://github.com/grantmcdermott/dbreg/actions/workflows/R-CMD-check.yaml/badge.svg" class="img-fluid" alt="GitHub Actions"></a>
<a href="https://grantmcdermott.com/dbreg/index.html"><img src="https://img.shields.io/badge/docs-homepage-blue.svg" class="img-fluid" alt="Docs"></a>
<!-- badges: end -->

Fast regressions on database backends.

## What

**dbreg** is an R package that leverages the power of databases to run
regressions on very large datasets, which may not fit into R's memory. 
Various acceleration strategies allow for highly efficient computation, while 
robust standard errors are computed from sufficient statistics. Our default
[DuckDB](https://duckdb.org/) backend provides a powerful, embedded analytics
engine to get users up and running with minimal effort. Users can also specify
alternative database backends, depending on their computing needs and setup.

The **dbreg** R package is inspired by, and has similar aims to, the
[duckreg](https://github.com/py-econometrics/duckreg) Python package.
This implementation offers some idiomatic, R-focused features like a formula
interface and "pretty" print methods. But our long-term goal is that these two
packages should be aligned in terms of core feature parity.

## Install

**dbreg** can be installed from
[R-universe](https://grantmcdermott.r-universe.dev/).

```r
install.packages(
   "dbreg",
   repos = c("https://grantmcdermott.r-universe.dev", getOption("repos"))
)
```

We plan to submit **dbreg** to CRAN in 2026Q1. See our
[TO-DO](https://github.com/grantmcdermott/dbreg/issues/5) list for an idea of
what still needs to be completed. Until then, please help us by kicking the
tyres and creating GitHub issues for both bug reports and feature requests.

## Quickstart

### Small dataset

To get ourselves situated, we'll first demonstrate by using an in-memory R
dataset.

```{r}
#| label: trade-dbreg
library(dbreg)
library(fixest) # for data and comparison

data("trade", package = "fixest")

dbreg(Euros ~ dist_km | Destination + Origin, data = trade, vcov = 'hc1')
```

Behind the scenes, **dbreg** has compressed the original dataset down from
nearly 40,000 observations to only 210, before running the final (weighted)
regression on this much smaller data object. This compression procedure trick
follows [Wang _et al._ (2021)](https://doi.org/10.48550/arXiv.2102.11297) and
effectively allows us to compute on a much lighter object, saving time and
memory. We can confirm that it still gives the same result as running 
`fixest::feols` on the full dataset:

```{r}
#| label: trade-feols
feols(Euros ~ dist_km | Destination + Origin, data = trade, vcov = 'hc1')
```

### Big dataset

For a more appropriate **dbreg** use-case, let's run a regression on some NYC
taxi data. (Download instructions
[here](https://grantmcdermott.com/duckdb-polars/requirements.html#nyc-taxi-data).)
The dataset that we're working with here is about 180 million rows deep and
takes up 8.5 GB on disk.^[
   To be clear, this dataset would occupy significantly more RAM than 8.5
   GB if we loaded it into R's memory, due to data serialization and the switch
   to richer representation formats (e.g., ordered factors require more memory).
   So there's a good chance that just trying to load this raw dataset into R
   would cause your whole system to crash... never mind doing any statistical
   analysis on it.]
**dbreg** offers two basic ways to analyse and interact with data of this size.

#### Option 1: "On-the-fly"

Use the `path` argument to read the data directly from disk and perform the
compression computation in an ephemeral DuckDB connection. This requires that
the data are small enough to fit into RAM... but please note that "small enough"
is a relative concept. Thanks to DuckDB's incredible efficiency, your RAM should
be able to handle very large datasets that would otherwise crash your R session,
and require only a fraction of the computation time. Note that we also invoke
the (optional) `verbose  = TRUE` argument to print additional information about
the estimation strategy.

```{r}
#| label: nyc-path
dbreg(
   tip_amount ~ fare_amount + passenger_count | month + vendor_name,
   path = "read_parquet('nyc-taxi/**/*.parquet')", ## path to hive-partitioned dataset
   vcov = "hc1",
   verbose = TRUE ## optional (print info about the estimation strategy)
)
```

Note the size of the original dataset, which is nearly 180 million rows, versus
the compressed dataset, which is down to only 70k. On my laptop (M4 MacBook Pro)
this regression completes in **under 3 seconds**... and that includes the time
it took to determine an optimal estimation strategy, as well as read the data
from disk!^[
   If we provided an explicit `dbreg(..., strategy = "compress")` argument
   (thus skipping the automatic strategy determination), then the total
   computation time drops to _less than 1 second_...]

In case you were wondering, obtaining clustered standard errors is just as easy;
simply pass the relevant cluster variable as a formula to the `vcov` argument.
Since we know that the optimal acceleration strategy is `"compress"`, we'll also
go ahead a specify this explicitly to skip the auto strategy overhead.

```{r}
#| label: nyc-cluster
dbreg(
   tip_amount ~ fare_amount + passenger_count | month + vendor_name,
   path     = "read_parquet('nyc-taxi/**/*.parquet')",
   vcov     = ~month,    # clustered SEs
   strategy = "compress" # skip auto strategy overhead
)
```


#### Option 2: Persistent database

While querying on-the-fly with our default DuckDB backend is both convenient and 
extremely performant, you can also run regressions against existing tables in a
persistent database connection. This could be DuckDB, but it could also be _any_
other [supported backend](https://r-dbi.org/backends/).
All you need to do is specify the appropriate `conn` and `table` arguments.

```{r}
#| label: nyc-dbi
# load the DBI package to connect to a persistent database
library(DBI)

# create connection to persistent DuckDB database (could be any supported backend)
con = dbConnect(duckdb::duckdb(), dbdir = "nyc.db")

# create a 'taxi' table in our new nyc.db database from our parquet dataset
dbExecute(
   con,
   "
   CREATE TABLE taxi AS
      FROM read_parquet('nyc-taxi/**/*.parquet')
      SELECT tip_amount, fare_amount, passenger_count, month, vendor_name
   "
)

# now run our regression against this conn+table combo
dbreg(
   tip_amount ~ fare_amount + passenger_count | month + vendor_name,
   conn = con,     # database connection,
   table = "taxi", # table name
   vcov = ~month,
   strategy = "compress"
)
```

Result: we get the same coefficient and standard error estimates as earlier.

::: {.callout-tip}
## Create Temporary Views

If you don't want to create a persistent database (and materialize data), a
nice alternative is `CREATE VIEW`. This lets you define subsets or computed
columns on-the-fly. For example, to regress on Q1 2012 data with a day-of-week
fixed effect:
```r
dbExecute(con, "
   CREATE VIEW nyc_subset AS
   SELECT
      tip_amount, trip_distance, passenger_count,
      vendor_name, month,
      dayofweek(dropoff_datetime) AS dofw
   FROM read_parquet('nyc-taxi/**/*.parquet')
   WHERE year = 2012 AND month <= 3
")

dbreg(
   tip_amount ~ trip_distance + passenger_count | month + dofw + vendor_name,
   conn = con,
   table = "nyc_subset",
   vcov = ~dofw
)
```
:::

We'll close by doing some (optional) clean up.

```{r}
#| label: nyc-cleanup
dbRemoveTable(con, "taxi")
dbDisconnect(con)
unlink("nyc.db") # remove from disk
```

## Bonus: Binscatter + interactions

The companion `dbbinsreg()` function provides a quick way to visualize
relationships in large datasets. Here we plot average tips by month:

```{r}
#| label: nyc-binsreg
dbbinsreg(
   tip_amount ~ month, nbins = 12,
   path = "read_parquet('nyc-taxi/**/*.parquet')"
)
```

The plot reveals a striking jump in tips starting in September. We can
investigate whether this jump differed by taxi vendor using an interaction
model. First, create a view with a post-September indicator:

```{r}
#| label: bonus-view
# re-establish a (new) duckdb connection
con = dbConnect(duckdb::duckdb(), shutdown = TRUE)

# create a temporary view with a post-September dummy
dbExecute(
   con,
   "
   CREATE VIEW nyc_post AS
   SELECT 
      tip_amount, vendor_name, month,
      CAST(month >= 9 AS INTEGER) AS post
   FROM read_parquet('nyc-taxi/**/*.parquet')
   "
)
```

Then run a DiD-style regression:

```{r}
#| label: bonus-did
dbreg(
   tip_amount ~ post * vendor_name | month,
   conn = con,
   table = "nyc_post"
)
```

The results confirm a $0.23 jump in tips post-September, with a small
additional increase for VTS taxis.

## Acceleration strategies and limitations

All of the examples in this README have made use of the `"compress"` strategy.
But the compression trick is not the only game in town and `dbreg` supports
several other acceleration strategies: `"moments"`, `"demean"`, and `"mundlak"`.
Depending on your data and regression requirements, one of these other
strategies may better suit your problem. The good news is that (the default)
`strategy = "auto"` option uses some intelligent heuristics to determine which
strategy is (probably) optimal for each case. You can set the `verbose = TRUE`
argument to get real-time feedback about the decision criteria being used.
The [Acceleration Strategies](https://grantmcdermott.com/dbreg/man/dbreg.html#acceleration-strategies)
section of the `?dbreg` helpfile contains a lot of detail about the different
options and tradeoffs involved, so please do consult the documentation.

In brief, we can say that **dbreg** works best when the fixed effects are
low-dimensional relative to the data size, yielding high compression ratios,
which in turn enable the remarkable speed-ups that we have demonstrated above.
In the specific case of the NYC taxi data, we are able to compress 180 million
rows down to just 70k observations exactly because the FE groups (month ×
vendor) only have 24 unique combinations. Compression becomes less effective
for "true" panel data (repeated cross sections) with high-dimensional unit and
time FE, where N >> T. In such cases, grouping by (X, unit, time) yields little
to no compression since each combination is essentially unique. The `"demean"`
and `"mundlak"` strategies provide a nice alternative here, since they reduce
dimensionality by taking covariate averages. While this is not as efficient as
the `"compress"` approach, all computation is done on the database backend and
this means we can run really big regressions without crashing our R session.

Please note that [**fixest**](https://lrberge.github.io/fixest/) remains an
_excellent_ choice for datasets that fit in R's memory, especially for
high-dimensional FE problems where its iterative demeaning algorithm remains
best in class.

## Acknowledgements

**dbreg** is indebted to the following open-source projects:

- [duckreg](https://github.com/py-econometrics/duckreg) ([Lal _et al._, 2024](https://arxiv.org/abs/2410.09952)). The original Python package that inspired this R implementation.
- [etwfe](https://grantmcdermott.com/etwfe/) (McDermott). A prior R implementation that employs compression-based estimation (albeit in a narrower context).
- [fixest](https://lrberge.github.io/fixest/) (Bergé _et al_, 2026). For its elegant formula syntax and user API, which we deliberately try to emulate alongside its performance philosophy.
- [DBI](https://dbi.r-dbi.org/) (R-SIG-DB, Wickham & Müller). The R database interface layer, which handles all of our SQL parsing and backend connectivity under the hood.
- [DuckDB](https://duckdb.org/) (Mühleisen & Raasveldt). The amazingly powerful embedded analytics engine, which powers all of our default operations.

We also build on the following theory papers:

- [Arkhangelsky & Imbens (2024)](https://doi.org/10.1093/restud/rdad089)
- [Mundlak (1978)](https://doi.org/10.2307/1913646)
- [Wang _et al._ (2021)](https://doi.org/10.48550/arXiv.2102.11297)